import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { motion, AnimatePresence, useMotionValue, useSpring } from 'framer-motion';
import { fabric } from 'fabric';
import { 
  Eraser, 
  Settings, 
  RotateCcw, 
  Trash2, 
  Eye, 
  EyeOff,
  Circle,
  Square,
  Minus,
  Zap,
  Target,
  MousePointer,
  Layers,
  History,
  Sparkles,
  X
} from 'lucide-react';
import PropTypes from 'prop-types';

/**
 * ⁄©ÿßŸÖŸæŸàŸÜŸÜÿ™ ÿ≠ÿ±ŸÅŸá‚Äåÿß€å ÿßÿ®ÿ≤ÿßÿ± Ÿæÿß⁄©‚Äå⁄©ŸÜ
 * ŸÇÿßÿ®ŸÑ€åÿ™‚ÄåŸáÿß:
 * - ÿ™ŸÜÿ∏€åŸÖ ÿßŸÜÿØÿßÿ≤Ÿá Ÿæÿß⁄©‚Äå⁄©ŸÜ ÿ®ÿß ⁄©ŸÜÿ™ÿ±ŸÑ ÿØŸÇ€åŸÇ
 * - Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥ ÿ≤ŸÜÿØŸá ŸÖÿ≠ÿØŸàÿØŸá Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ
 * - ÿßŸÜŸàÿßÿπ ŸÖÿÆÿ™ŸÑŸÅ Ÿæÿß⁄©‚Äå⁄©ŸÜ (ÿØÿß€åÿ±Ÿá‚Äåÿß€åÿå ŸÖÿ±ÿ®ÿπ€åÿå ÿÆÿ∑€å)
 * - ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá ÿ¥ŸÅÿßŸÅ€åÿ™ Ÿà ŸÅÿ¥ÿßÿ±
 * - ÿπŸÖŸÑ€åÿßÿ™ undo/redo ŸáŸàÿ¥ŸÖŸÜÿØ
 * - Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿßÿ≤ ⁄©€åÿ®Ÿàÿ±ÿØ shortcuts
 */
const EraseToolComponent = ({ 
  canvas, 
  isActive = false, 
  onToolChange,
  onSettingsChange,
  onClose,
  initialSettings = {}
}) => {
  // State ŸÖÿØ€åÿ±€åÿ™ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿßÿ®ÿ≤ÿßÿ±
  const [settings, setSettings] = useState({
    size: 15,
    minSize: 5,
    maxSize: 100,
    opacity: 0.8,
    shape: 'circle', // 'circle', 'square', 'line'
    pressure: true,
    preview: true,
    smoothing: 0.7,
    hardness: 0.8,
    spacing: 0.25,
    flow: 1.0,
    dynamics: true,
    antiAliasing: true,
    blendMode: 'destination-out',
    ...initialSettings
  });

  // State ŸÖÿØ€åÿ±€åÿ™ UI
  const [showSettings, setShowSettings] = useState(false);
  const [isErasing, setIsErasing] = useState(false);
  const [previewPosition, setPreviewPosition] = useState(null);
  const [erasedObjects, setErasedObjects] = useState([]);
  const [pressure, setPressure] = useState(1.0);
  const [velocity, setVelocity] = useState(0);
  const [eraserTrail, setEraserTrail] = useState([]);
  const [isHovering, setIsHovering] = useState(false);
  const [stats, setStats] = useState({
    totalErased: 0,
    sessionTime: 0,
    undoCount: 0
  });

  // Refs ÿ®ÿ±ÿß€å ŸÖÿØ€åÿ±€åÿ™ event handlers
  const mousePositionRef = useRef({ x: 0, y: 0 });
  const lastErasePosRef = useRef(null);
  const erasingPathRef = useRef([]);
  const undoStackRef = useRef([]);
  const redoStackRef = useRef([]);
  const isMouseDownRef = useRef(false);
  const pressureRef = useRef(1.0);
  const velocityRef = useRef({ x: 0, y: 0 });
  const lastTimeRef = useRef(0);
  const animationFrameRef = useRef(null);
  const trailTimeoutRef = useRef(null);
  const sessionStartRef = useRef(Date.now());
  const settingsRef = useRef(null);
  
  // Motion values ÿ®ÿ±ÿß€å ÿßŸÜ€åŸÖ€åÿ¥ŸÜ‚ÄåŸáÿß€å smooth
  const previewScale = useMotionValue(1);
  const previewOpacity = useMotionValue(0.8);

  // ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿßŸÜÿØÿßÿ≤Ÿá ŸàÿßŸÇÿπ€å ÿ®ÿß ÿØÿ± ŸÜÿ∏ÿ± ⁄Ø€åÿ±€å ŸÅÿ¥ÿßÿ± Ÿà ÿ≥ÿ±ÿπÿ™
  const actualSize = useMemo(() => {
    let baseSize = settings.size;
    
    if (settings.pressure) {
      baseSize *= (0.3 + pressure * 0.7); // ŸÅÿ¥ÿßÿ± ÿ®€åŸÜ 30% ÿ™ÿß 100%
    }
    
    if (settings.dynamics && velocity > 0) {
      const velocityFactor = Math.min(velocity / 1000, 1); // ŸÜÿ±ŸÖÿßŸÑ€åÿ≤Ÿá ÿ≥ÿ±ÿπÿ™
      baseSize *= (1 - velocityFactor * 0.3); // ÿ≥ÿ±ÿπÿ™ ÿ®ÿßŸÑÿß = ÿßŸÜÿØÿßÿ≤Ÿá ⁄©ŸÖÿ™ÿ±
    }
    
    return Math.max(settings.minSize, Math.min(settings.maxSize, baseSize));
  }, [settings.size, settings.pressure, settings.dynamics, settings.minSize, settings.maxSize, pressure, velocity]);

  // ŸÖÿØ€åÿ±€åÿ™ ÿ¥ÿ±Ÿàÿπ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ≥ÿßÿØŸá
  const handleMouseDown = useCallback((e) => {
    if (!canvas || !isActive) return;

    e.e?.preventDefault?.();
    e.e?.stopPropagation?.();

    canvas.discardActiveObject();

    const pointer = canvas.getPointer(e.e);

    isMouseDownRef.current = true;
    setIsErasing(true);
    lastErasePosRef.current = pointer;

    console.log('\n\nüßπüßπüßπ =============== MOUSE DOWN - ERASING STARTED ===============');
    console.log('üìç Mouse down at:', pointer);
    console.log('üé® Canvas objects count:', canvas.getObjects().length);
    console.log('‚öôÔ∏è isMouseDownRef.current:', isMouseDownRef.current);

    // Start erasing immediately
    performEraseAction(pointer);
  }, [canvas, isActive]);

  // ŸÖÿØ€åÿ±€åÿ™ ÿ≠ÿ±⁄©ÿ™ ÿ≥ÿßÿØŸá
  const handleMouseMove = useCallback((e) => {
    if (!canvas || !isActive) return;

    const pointer = canvas.getPointer(e.e);
    setPreviewPosition(pointer);

    // ÿ±ŸÜÿØÿ± ŸÅŸàÿ±€å Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥
    const ctx = canvas.contextTop;
    if (ctx) {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(pointer.x, pointer.y, settings.size / 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    if (isMouseDownRef.current) {
      console.log('üñ±Ô∏è MOUSE MOVE (dragging) at:', pointer, '| isMouseDown:', isMouseDownRef.current);
      performEraseAction(pointer);
    } else {
      // Just hovering, not erasing
      console.log('üëÜ MOUSE MOVE (hover) at:', pointer, '| isMouseDown:', isMouseDownRef.current);
    }
  }, [canvas, isActive, settings.size]);

  // ŸÖÿØ€åÿ±€åÿ™ Ÿæÿß€åÿßŸÜ Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ
  const handleMouseUp = useCallback(() => {
    if (!canvas || !isActive) return;

    console.log('üõë =============== MOUSE UP - ERASING FINISHED ===============');
    console.log('‚öôÔ∏è Setting isMouseDownRef.current to false');

    isMouseDownRef.current = false;
    setIsErasing(false);
    lastErasePosRef.current = null;

    console.log('‚úÖ Erasing session ended\n\n');
  }, [canvas, isActive]);

  // ŸÖÿØ€åÿ±€åÿ™ ÿÆÿ±Ÿàÿ¨ ŸÖÿßŸàÿ≥ ÿßÿ≤ canvas
  const handleMouseLeave = useCallback(() => {
    setPreviewPosition(null);
    if (isMouseDownRef.current) {
      handleMouseUp();
    }
  }, [handleMouseUp]);

  // Helper function: calculate distance from point to line
  const pointToLineDistance = useCallback((px, py, x1, y1, x2, y2) => {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) {
      param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;

    return Math.sqrt(dx * dx + dy * dy);
  }, []);

  // ÿ™ÿßÿ®ÿπ ÿ≥ÿßÿØŸá ÿ®ÿ±ÿß€å Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ - ÿ®ÿß ÿØŸÇÿ™ ÿ®ÿßŸÑÿß
  const performEraseAction = useCallback((point) => {
    if (!canvas) return;

    console.log('\nüßπ ==================== PERFORM ERASE ACTION ====================');
    console.log('üéØ Eraser position:', point);
    console.log('üìè Eraser size:', settings.size);
    console.log('üîç Tolerance:', 8);

    const objects = canvas.getObjects();
    const objectsToRemove = [];
    const tolerance = 8;

    console.log('üì¶ Total objects on canvas:', objects.length);

    if (objects.length === 0) {
      console.log('‚ö†Ô∏è No objects on canvas to erase!');
      return;
    }

    objects.forEach((obj, idx) => {
      // Skip background and preview objects
      if (obj === canvas.backgroundImage || obj._isPreview) {
        console.log(`Object ${idx}: SKIPPED (background/preview)`);
        return;
      }

      let shouldErase = false;

      console.log(`\n--- Object ${idx} ---`);
      console.log('Object type:', obj.type);
      console.log('Object position - left:', obj.left, 'top:', obj.top);
      console.log('Stroke width:', obj.strokeWidth);

      // ÿ®ÿ±ÿ±ÿ≥€å ÿØŸÇ€åŸÇ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜŸàÿπ ÿ¢ÿ®ÿ¨⁄©ÿ™
      if (obj.type === 'line') {
        // ÿ®ÿ±ÿß€å ÿÆÿ∑Ÿàÿ∑: ÿ®ÿ±ÿ±ÿ≥€å ŸÅÿßÿµŸÑŸá ŸÜŸÇÿ∑Ÿá ÿ™ÿß ÿÆÿ∑
        const x1 = obj.x1 + obj.left;
        const y1 = obj.y1 + obj.top;
        const x2 = obj.x2 + obj.left;
        const y2 = obj.y2 + obj.top;

        console.log('Line endpoints:', { x1, y1, x2, y2 });

        const distance = pointToLineDistance(point.x, point.y, x1, y1, x2, y2);
        const strokeWidth = obj.strokeWidth || 1;
        const threshold = strokeWidth / 2 + tolerance;

        console.log('Distance to line:', distance.toFixed(2), 'Threshold:', threshold.toFixed(2));

        if (distance <= threshold) {
          shouldErase = true;
          console.log('‚úÖ WILL ERASE - within threshold');
        } else {
          console.log('‚ùå NO ERASE - too far from line');
        }
      } else if (obj.type === 'path') {
        // ÿ®ÿ±ÿß€å ŸÖÿ≥€åÿ±Ÿáÿß (brush strokes): ÿ®ÿ±ÿ±ÿ≥€å ÿØŸÇ€åŸÇ ŸÜŸÇÿßÿ∑ ŸÖÿ≥€åÿ±
        console.log('üé® PATH OBJECT FOUND');
        console.log('   Path points count:', obj.path?.length || 0);
        console.log('   Stroke color:', obj.stroke);
        console.log('   Stroke width:', obj.strokeWidth);

        if (obj.path && obj.path.length > 0) {
          const strokeWidth = obj.strokeWidth || 1;
          const threshold = strokeWidth / 2 + tolerance;

          console.log('   üéØ Threshold for hit detection:', threshold.toFixed(2), 'px');
          console.log('   üìç First 5 path points:', obj.path.slice(0, 5).map((p, i) => `[${i}]: [${p[1]?.toFixed(1)}, ${p[2]?.toFixed(1)}]`).join(', '));

          let minDistance = Infinity;
          let closestPoint = null;
          let hitPoints = [];

          // ÿ®ÿ±ÿ±ÿ≥€å ŸÅÿßÿµŸÑŸá ÿßÿ≤ Ÿáÿ± ŸÜŸÇÿ∑Ÿá ÿØÿ± ŸÖÿ≥€åÿ±
          for (let i = 0; i < obj.path.length; i++) {
            const pathPoint = obj.path[i];
            if (pathPoint.length >= 3) {
              // Path coordinates are already in global space, no need to add obj.left/top
              const px = pathPoint[1];
              const py = pathPoint[2];

              const distance = Math.sqrt(
                Math.pow(point.x - px, 2) + Math.pow(point.y - py, 2)
              );

              if (distance < minDistance) {
                minDistance = distance;
                closestPoint = { px, py, index: i, distance: distance.toFixed(2) };
              }

              if (distance <= threshold) {
                shouldErase = true;
                hitPoints.push({ index: i, distance: distance.toFixed(2) });
              }

              // ÿ®ÿ±ÿ±ÿ≥€å ŸÅÿßÿµŸÑŸá ÿßÿ≤ ÿÆÿ∑Ÿàÿ∑ ÿ®€åŸÜ ŸÜŸÇÿßÿ∑
              if (i > 0 && obj.path[i - 1].length >= 3) {
                const prevPx = obj.path[i - 1][1];
                const prevPy = obj.path[i - 1][2];

                const lineDistance = pointToLineDistance(point.x, point.y, prevPx, prevPy, px, py);

                if (lineDistance < minDistance) {
                  minDistance = lineDistance;
                  closestPoint = { px, py, index: i, distance: lineDistance.toFixed(2), type: 'line-segment' };
                }

                if (lineDistance <= threshold) {
                  shouldErase = true;
                  hitPoints.push({ index: `${i-1}-${i}`, distance: lineDistance.toFixed(2), type: 'line' });
                }
              }
            }
          }

          if (!shouldErase) {
            console.log(`   ‚ùå NO HIT - Closest distance: ${minDistance.toFixed(2)}px at`, closestPoint);
          } else {
            console.log(`   ‚úÖ HIT DETECTED! - Hit ${hitPoints.length} points/segments:`, hitPoints);
            console.log('   üî™ Instead of partial erase, removing entire object for now...');

            // For now, just remove the entire object when hit
            // TODO: Implement proper path splitting for partial erase
            shouldErase = true;
            console.log('   ‚ö†Ô∏è Marking object for complete removal');
          }
        }
      } else {
        // ÿ®ÿ±ÿß€å ÿ≥ÿß€åÿ± ÿßÿ¥€åÿßÿ°: ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ containsPoint
        const bounds = obj.getBoundingRect();

        if (point.x >= bounds.left - tolerance &&
            point.x <= bounds.left + bounds.width + tolerance &&
            point.y >= bounds.top - tolerance &&
            point.y <= bounds.top + bounds.height + tolerance) {

          if (obj.containsPoint) {
            const objPoint = new fabric.Point(point.x, point.y);
            shouldErase = obj.containsPoint(objPoint);
          } else {
            shouldErase = true;
          }
        }
      }

      if (shouldErase) {
        console.log('‚≠ê Adding to removal list');
        objectsToRemove.push(obj);
      }
    });

    console.log('\nüìä ========== SUMMARY ==========');
    console.log('Objects marked for complete removal:', objectsToRemove.length);

    // Remove objects
    if (objectsToRemove.length > 0) {
      objectsToRemove.forEach((obj, idx) => {
        console.log(`   üóëÔ∏è Removing object ${idx}:`, obj.type);
        canvas.remove(obj);
      });
      canvas.requestRenderAll();
      console.log('‚úÖ Successfully removed', objectsToRemove.length, 'objects');
    } else {
      console.log('‚ÑπÔ∏è No objects marked for complete removal');
    }

    console.log('üì¶ Final canvas objects count:', canvas.getObjects().length);
    console.log('======================================================\n');
  }, [canvas, actualSize, pointToLineDistance, settings.size]);


  // ÿ®ÿ±ÿ±ÿ≥€å ŸÇÿ±ÿßÿ± ⁄Ø€åÿ±€å object ÿØÿ± ŸÖÿ≠ÿØŸàÿØŸá Ÿæÿß⁄©‚Äå⁄©ŸÜ
  const checkObjectInEraseBounds = (point, objBounds, size, shape) => {
    if (!objBounds || !point) return false;
    
    const centerX = objBounds.left + objBounds.width / 2;
    const centerY = objBounds.top + objBounds.height / 2;
    const radius = size / 2;

    switch (shape) {
      case 'circle':
        const distance = Math.sqrt(
          Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2)
        );
        // ÿ®Ÿáÿ®ŸàÿØ ÿØŸÇÿ™ ÿ™ÿ¥ÿÆ€åÿµ ÿ®ÿ±ÿÆŸàÿ±ÿØ
        return distance <= radius + Math.min(objBounds.width, objBounds.height) / 4;

      case 'square':
        return (
          point.x >= objBounds.left - radius &&
          point.x <= objBounds.left + objBounds.width + radius &&
          point.y >= objBounds.top - radius &&
          point.y <= objBounds.top + objBounds.height + radius
        );

      case 'line':
        return (
          Math.abs(point.y - centerY) <= radius &&
          point.x >= objBounds.left - radius &&
          point.x <= objBounds.left + objBounds.width + radius
        );

      default:
        return false;
    }
  };

  // Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿ®ÿÆÿ¥€å ÿßÿ≤ ŸÖÿ≥€åÿ± (ÿ®ÿ±ÿß€å ÿÆÿ∑Ÿàÿ∑ Ÿà paths)
  const erasePartialPath = (pathObj, erasePoint, size) => {
    if (!pathObj.path) return [];

    const remainingSegments = [];
    let currentSegment = [];
    const radius = size / 2;

    pathObj.path.forEach((point) => {
      const distance = Math.sqrt(
        Math.pow(point[1] - erasePoint.x, 2) + Math.pow(point[2] - erasePoint.y, 2)
      );

      if (distance > radius) {
        currentSegment.push(point);
      } else {
        if (currentSegment.length > 1) {
          remainingSegments.push([...currentSegment]);
        }
        currentSegment = [];
      }
    });

    if (currentSegment.length > 1) {
      remainingSegments.push([...currentSegment]);
    }

    return remainingSegments.map((segment) => {
      return new fabric.Path(segment, {
        stroke: pathObj.stroke,
        strokeWidth: pathObj.strokeWidth,
        fill: pathObj.fill,
        selectable: false,
        evented: false
      });
    });
  };


  // ÿ™ÿ∫€å€åÿ± ÿ™ŸÜÿ∏€åŸÖÿßÿ™
  const updateSettings = useCallback((newSettings) => {
    setSettings(prev => {
      const updated = { ...prev, ...newSettings };
      onSettingsChange?.(updated);
      return updated;
    });
  }, [onSettingsChange]);

  // Undo ÿ¢ÿÆÿ±€åŸÜ ÿπŸÖŸÑ€åÿßÿ™
  const handleUndo = useCallback(() => {
    if (undoStackRef.current.length > 0) {
      const lastState = undoStackRef.current.pop();
      canvas.loadFromJSON(lastState, () => {
        canvas.renderAll();
        console.log('‚è™ Undo ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ');
      });
    }
  }, [canvas]);

  // Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ŸáŸÖŸá objects
  const handleClearAll = useCallback(() => {
    if (!canvas) return;

    const canvasState = JSON.stringify(canvas.toJSON());
    undoStackRef.current.push(canvasState);

    const objects = canvas.getObjects();
    objects.forEach(obj => {
      if (obj !== canvas.backgroundImage) {
        canvas.remove(obj);
      }
    });
    
    canvas.renderAll();
    setErasedObjects([]);
    console.log('üóëÔ∏è ŸáŸÖŸá objects Ÿæÿß⁄© ÿ¥ÿØŸÜÿØ');
  }, [canvas]);

  // ÿ±ŸÜÿØÿ± Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥ ÿ≥ÿßÿØŸá
  const renderPreview = useCallback(() => {
    if (!canvas || !previewPosition) return;

    const ctx = canvas.contextTop;
    if (!ctx) return;

    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ÿ±ÿ≥ŸÖ ÿØÿß€åÿ±Ÿá ŸÇÿ±ŸÖÿ≤ ÿ≥ÿßÿØŸá - ŸáŸÖ€åÿ¥Ÿá ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ŸàÿØ
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(previewPosition.x, previewPosition.y, actualSize / 2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  }, [canvas, previewPosition, actualSize]);

  // ÿ™ŸÜÿ∏€åŸÖ event listeners ÿ®ÿß useRef ÿ®ÿ±ÿß€å ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ recreate ÿ¥ÿØŸÜ
  const handlersRef = useRef({
    handleMouseDown: null,
    handleMouseMove: null,
    handleMouseUp: null,
    handleMouseLeave: null
  });

  // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å handlers ÿØÿ± ref
  useEffect(() => {
    handlersRef.current.handleMouseDown = handleMouseDown;
    handlersRef.current.handleMouseMove = handleMouseMove;
    handlersRef.current.handleMouseUp = handleMouseUp;
    handlersRef.current.handleMouseLeave = handleMouseLeave;
  });

  // ÿ™ŸÜÿ∏€åŸÖ event listeners
  useEffect(() => {
    if (!canvas || !isActive) return;

    // ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿßŸÜÿ™ÿÆÿßÿ® objects
    canvas.discardActiveObject();
    canvas.renderAll();

    const mouseDownHandler = (e) => handlersRef.current.handleMouseDown?.(e);
    const mouseMoveHandler = (e) => handlersRef.current.handleMouseMove?.(e);
    const mouseUpHandler = (e) => handlersRef.current.handleMouseUp?.(e);
    const mouseLeaveHandler = (e) => handlersRef.current.handleMouseLeave?.(e);

    canvas.on('mouse:down', mouseDownHandler);
    canvas.on('mouse:move', mouseMoveHandler);
    canvas.on('mouse:up', mouseUpHandler);
    canvas.on('mouse:leave', mouseLeaveHandler);

    return () => {
      canvas.off('mouse:down', mouseDownHandler);
      canvas.off('mouse:move', mouseMoveHandler);
      canvas.off('mouse:up', mouseUpHandler);
      canvas.off('mouse:leave', mouseLeaveHandler);
    };
  }, [canvas, isActive]);

  // ÿ±ŸÜÿØÿ± Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥
  useEffect(() => {
    renderPreview();
  }, [renderPreview]);

  // ÿ™ŸÜÿ∏€åŸÖ cursor Ÿà ÿ≠ÿßŸÑÿ™ canvas
  useEffect(() => {
    if (canvas && isActive) {
      canvas.defaultCursor = 'crosshair';
      canvas.hoverCursor = 'crosshair';
      canvas.isDrawingMode = false;
      canvas.selection = false;
      canvas.renderAll();
    } else if (canvas && !isActive) {
      canvas.selection = true;
      canvas.defaultCursor = 'default';
      canvas.hoverCursor = 'move';
      canvas.renderAll();
    }
  }, [canvas, isActive]);

  // Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ÿØÿ± deactivation
  useEffect(() => {
    if (canvas && !isActive) {
      const ctx = canvas.contextTop;
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
  }, [canvas, isActive]);

  // ŸÖÿØ€åÿ±€åÿ™ ⁄©ŸÑ€å⁄© ÿ®€åÿ±ŸàŸÜ ŸÖŸÜŸà Ÿà ÿ®ÿ≥ÿ™ŸÜ ÿ™ŸÜÿ∏€åŸÖÿßÿ™
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (settingsRef.current && !settingsRef.current.contains(event.target)) {
        // ÿ®ÿ≥ÿ™ŸÜ ŸÖŸÜŸà ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ŸàŸÇÿ™€å ÿÆÿßÿ±ÿ¨ ÿßÿ≤ ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ŸÖ€å‚Äåÿ¥ŸàÿØ
        setShowSettings(false);
      }
    };

    // listener ÿßÿµŸÑ€å ÿ®ÿ±ÿß€å ÿ™ŸÖÿßŸÖ ÿµŸÅÿ≠Ÿá
    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('touchstart', handleClickOutside);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [showSettings]);

  return (
    <motion.div 
      ref={settingsRef}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 20 }}
      className="eraser-tool bg-white rounded-lg shadow-lg border border-gray-200 p-4 max-w-sm"
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Eraser className="w-5 h-5 text-red-500" />
          <h3 className="font-semibold text-gray-800">ÿßÿ®ÿ≤ÿßÿ± Ÿæÿß⁄©‚Äå⁄©ŸÜ</h3>
        </div>
        <div className="flex items-center gap-1">
          {/* Close Button */}
          {onClose && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                onClose();
              }}
              className="p-2 hover:bg-red-100 text-red-600 rounded-lg transition-colors"
              title="ÿ®ÿ≥ÿ™ŸÜ ŸæŸÜŸÑ"
            >
              <X className="w-4 h-4" />
            </button>
          )}
          {/* Settings Button */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              // Single click no longer opens the settings menu
            }}
            onDoubleClick={(e) => {
              e.stopPropagation();
              setShowSettings(!showSettings);
            }}
            onContextMenu={(e) => {
              e.preventDefault();
              e.stopPropagation();
              setShowSettings(!showSettings);
            }}
            className={`p-2 hover:bg-gray-100 rounded-lg transition-colors ${
              showSettings ? 'bg-gray-100' : ''
            }`}
            title="ÿØÿßÿ®ŸÑ ⁄©ŸÑ€å⁄©/ÿ±ÿßÿ≥ÿ™ ⁄©ŸÑ€å⁄©: ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá"
          >
            <Settings className="w-4 h-4 text-gray-600" />
          </button>
        </div>
      </div>

      {/* ÿßŸÜÿØÿßÿ≤Ÿá Ÿæÿß⁄©‚Äå⁄©ŸÜ */}
      <div className="mb-4">
        <div className="flex items-center justify-between mb-2">
          <label className="text-sm font-medium text-gray-700">ÿßŸÜÿØÿßÿ≤Ÿá</label>
          <span className="text-xs text-gray-500">{actualSize}px</span>
        </div>
        <input
          type="range"
          min={settings.minSize}
          max={settings.maxSize}
          value={settings.size}
          onChange={(e) => updateSettings({ size: parseInt(e.target.value) })}
          className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
        />
        <div className="flex justify-between text-xs text-gray-400 mt-1">
          <span>{settings.minSize}px</span>
          <span>{settings.maxSize}px</span>
        </div>
      </div>

      {/* ŸÜŸàÿπ Ÿæÿß⁄©‚Äå⁄©ŸÜ */}
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700 mb-2">ÿ¥⁄©ŸÑ</label>
        <div className="flex gap-2">
          {[
            { value: 'circle', icon: Circle, label: 'ÿØÿß€åÿ±Ÿá' },
            { value: 'square', icon: Square, label: 'ŸÖÿ±ÿ®ÿπ' },
            { value: 'line', icon: Minus, label: 'ÿÆÿ∑' }
          ].map(({ value, icon: Icon, label }) => (
            <button
              key={value}
              onClick={() => updateSettings({ shape: value })}
              className={`flex-1 flex items-center justify-center gap-1 py-2 px-3 rounded-lg text-sm transition-colors ${
                settings.shape === value
                  ? 'bg-red-100 text-red-700 border-red-200'
                  : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
              }`}
            >
              <Icon className="w-4 h-4" />
              <span className="hidden sm:inline">{label}</span>
            </button>
          ))}
        </div>
      </div>

      {/* Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥ ÿßŸÜÿØÿßÿ≤Ÿá */}
      <div className="mb-4 flex items-center justify-center bg-gray-50 rounded-lg p-4">
        <div 
          className={`border-2 border-dashed border-red-400 bg-red-100 ${
            settings.shape === 'square' ? '' : 'rounded-full'
          }`}
          style={{ 
            width: `${Math.min(actualSize, 60)}px`, 
            height: settings.shape === 'line' ? '4px' : `${Math.min(actualSize, 60)}px`,
          }}
        />
      </div>

      {/* ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá */}
      <AnimatePresence>
        {showSettings && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="space-y-3 mb-4 p-3 bg-gray-50 rounded-lg"
          >
            {/* ÿ¥ŸÅÿßŸÅ€åÿ™ */}
            <div>
              <div className="flex items-center justify-between mb-1">
                <label className="text-sm text-gray-600">ÿ¥ŸÅÿßŸÅ€åÿ™</label>
                <span className="text-xs text-gray-500">{Math.round(settings.opacity * 100)}%</span>
              </div>
              <input
                type="range"
                min="0.1"
                max="1"
                step="0.1"
                value={settings.opacity}
                onChange={(e) => updateSettings({ opacity: parseFloat(e.target.value) })}
                className="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer"
              />
            </div>

            {/* Smoothing */}
            <div>
              <div className="flex items-center justify-between mb-1">
                <label className="text-sm text-gray-600">ŸÜÿ±ŸÖ€å</label>
                <span className="text-xs text-gray-500">{Math.round(settings.smoothing * 100)}%</span>
              </div>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={settings.smoothing}
                onChange={(e) => updateSettings({ smoothing: parseFloat(e.target.value) })}
                className="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer"
              />
            </div>

            {/* ÿ™ŸÜÿ∏€åŸÖÿßÿ™ boolean */}
            <div className="flex items-center justify-between">
              <label className="text-sm text-gray-600">Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥</label>
              <button
                onClick={() => updateSettings({ preview: !settings.preview })}
                className="p-1"
              >
                {settings.preview ? 
                  <Eye className="w-4 h-4 text-blue-500" /> : 
                  <EyeOff className="w-4 h-4 text-gray-400" />
                }
              </button>
            </div>

            <div className="flex items-center justify-between">
              <label className="text-sm text-gray-600">ÿ≠ÿ≥ÿßÿ≥€åÿ™ ÿ®Ÿá ŸÅÿ¥ÿßÿ±</label>
              <button
                onClick={() => updateSettings({ pressure: !settings.pressure })}
                className={`w-10 h-5 rounded-full transition-colors ${
                  settings.pressure ? 'bg-blue-500' : 'bg-gray-300'
                }`}
              >
                <div className={`w-4 h-4 bg-white rounded-full transition-transform ${
                  settings.pressure ? 'translate-x-5' : 'translate-x-0.5'
                } translate-y-0.5`} />
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿπŸÖŸÑ€åÿßÿ™€å */}
      <div className="flex gap-2">
        <button
          onClick={() => {
            if (canvas) {
              // Add test objects
              const line = new fabric.Line([50, 50, 150, 150], {
                stroke: '#ff0000',
                strokeWidth: 3,
                selectable: true,
                evented: true
              });
              const rect = new fabric.Rect({
                left: 200,
                top: 100,
                width: 100,
                height: 80,
                fill: 'transparent',
                stroke: '#00ff00',
                strokeWidth: 2,
                selectable: true,
                evented: true
              });
              canvas.add(line);
              canvas.add(rect);
              canvas.renderAll();
              console.log('üìè Test objects added');
            }
          }}
          className="flex-1 flex items-center justify-center gap-2 py-2 px-3 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition-colors"
        >
          <Circle className="w-4 h-4" />
          <span className="text-sm">Add Test</span>
        </button>
        
        <button
          onClick={handleClearAll}
          className="flex-1 flex items-center justify-center gap-2 py-2 px-3 bg-red-100 text-red-700 rounded-lg hover:bg-red-200 transition-colors"
        >
          <Trash2 className="w-4 h-4" />
          <span className="text-sm">Clear All</span>
        </button>
      </div>

      {/* ŸÜŸÖÿß€åÿ¥ ÿ¢ŸÖÿßÿ± */}
      {erasedObjects.length > 0 && (
        <div className="mt-3 p-2 bg-yellow-50 border border-yellow-200 rounded text-xs text-yellow-800">
          {erasedObjects.length} ÿ¢ÿ®ÿ¨⁄©ÿ™ Ÿæÿß⁄© ÿ¥ÿØŸá
        </div>
      )}
    </motion.div>
  );
};

EraseToolComponent.propTypes = {
  canvas: PropTypes.object,
  isActive: PropTypes.bool,
  onToolChange: PropTypes.func,
  onSettingsChange: PropTypes.func,
  onClose: PropTypes.func,
  initialSettings: PropTypes.object,
};

export default EraseToolComponent;